import { EntityName, FieldType } from '@enums';
import {
  IBaseModel,
  IEntityConstructor,
  ISmallIntegerField,
  IStringField
} from '@interfaces';
import { ApiError } from '@shared/classes';
import { ApiErrorCode } from '@shared/enums';
import { IApiError } from '@shared/interfaces';
import { dateToIsoString, sanitizeDate } from '@shared/utilities';
import { Entity, Field } from '@types';

function _getSchemaValidationError<T extends IBaseModel>(
  entityName: EntityName,
  fieldName: Extract<keyof T, string>,
  fieldValue: string | undefined | null,
  remainingText: string,
  errorCode:
    | ApiErrorCode.databseSchemaValidationError
    | ApiErrorCode.databaseOptimisticConcurencyError = ApiErrorCode.databseSchemaValidationError,
  id?: string
) {
  const idString = id ? ` with id: '${id}' ` : ' ';

  return {
    errorCode,
    message: `Record of type ${entityName}${idString}has invalid value for field - ${fieldName}: '${fieldValue}', ${remainingText}.`
  };
}

function _validateIntegerFieldValue<T extends IBaseModel>(
  entityName: EntityName,
  fieldName: Extract<keyof T, string>,
  field: Readonly<ISmallIntegerField>,
  fieldValue: number | undefined | null,
  id?: string
) {
  const errorMessages: string[] = [];

  if (typeof fieldValue !== 'number') {
    errorMessages.push();
  } else if (fieldValue !== (fieldValue | 0)) {
    errorMessages.push('this field must be an integer value');
  }

  return errorMessages.map((errorMessage) =>
    _getSchemaValidationError(
      entityName,
      fieldName,
      `${fieldValue}`,
      errorMessage,
      ApiErrorCode.databseSchemaValidationError,
      id
    )
  );
}

function _validateStringFieldValue<T extends IBaseModel>(
  entityName: EntityName,
  fieldName: Extract<keyof T, string>,
  field: Readonly<IStringField>,
  fieldValue: string | undefined | null,
  id?: string
) {
  const errorMessages: string[] = [];

  if (
    (!field.isNullable && (fieldValue === undefined || fieldValue === null)) ||
    (field.minLength !== undefined &&
      fieldValue !== undefined &&
      fieldValue !== null &&
      fieldValue.length < field.minLength)
  ) {
    errorMessages.push(
      `this field must contain at least ${field.minLength ?? 0} characters`
    );
  }

  if (
    field.maxLength < Infinity &&
    fieldValue !== undefined &&
    fieldValue !== null &&
    fieldValue.length > field.maxLength
  ) {
    errorMessages.push(
      `this field cannot exceed ${field.maxLength} characters`
    );
  }

  return errorMessages.map((errorMessage) =>
    _getSchemaValidationError(
      entityName,
      fieldName,
      fieldValue,
      errorMessage,
      ApiErrorCode.databseSchemaValidationError,
      id
    )
  );
}

export function validateFieldValues<T extends IBaseModel>(
  entity: Entity<T>,
  model?: T
) {
  const errors: IApiError[] = [];
  const entityConstructor = entity.constructor as IEntityConstructor<T>;
  const schema = entityConstructor.schema();
  const entityName = entityConstructor.entityName();

  if (!model && entity.id !== undefined) {
    errors.push(
      _getSchemaValidationError(
        entityName,
        'id',
        entity.id,
        'ids are auto-generated at the database level'
      )
    );
  } else if (model && entity.id !== model.id) {
    errors.push(
      _getSchemaValidationError(
        entityName,
        'id',
        entity.id,
        'ids are immutable',
        ApiErrorCode.databseSchemaValidationError,
        model.id
      )
    );
  }

  if (!model && entity.createdBy !== undefined) {
    _getSchemaValidationError(
      entityName,
      'createdBy',
      entity.createdBy,
      'createdBy is generated by the request context'
    );
  } else if (
    model &&
    entity.createdBy &&
    entity.createdBy !== model.createdBy
  ) {
    _getSchemaValidationError(
      entityName,
      'createdBy',
      entity.id,
      'createdBy is immutable',
      ApiErrorCode.databseSchemaValidationError,
      model.id
    );
  }

  if (!model && entity.createdDate !== undefined) {
    errors.push(
      _getSchemaValidationError(
        entityName,
        'createdDate',
        dateToIsoString(entity.createdDate),
        `createdDate is auto-generated at the database level`,
        ApiErrorCode.databseSchemaValidationError,
        entity.id
      )
    );
  } else if (model && entity.createdDate) {
    const modelTime = sanitizeDate(model.createdDate)?.getTime();
    const entityTime = sanitizeDate(entity.createdDate)?.getTime();

    if (modelTime !== entityTime) {
      const entityDateString = dateToIsoString(entity.createdDate);

      _getSchemaValidationError(
        entityName,
        'createdDate',
        entityDateString,
        `mismatched createdDate values, createdDate is immutable, createdDate for existing record: '${entityDateString}'`,
        ApiErrorCode.databseSchemaValidationError,
        model.id
      );
    }
  }

  if (!model && entity.updatedBy !== undefined) {
    _getSchemaValidationError(
      entityName,
      'updatedBy',
      entity.updatedBy,
      'updatedBy is generated by the request context'
    );
  } else if (
    model &&
    entity.updatedBy &&
    entity.updatedBy !== model.updatedBy
  ) {
    _getSchemaValidationError(
      entityName,
      'updatedBy',
      entity.id,
      'updatedBy is user immutable',
      ApiErrorCode.databseSchemaValidationError,
      model.id
    );
  }

  if (!model && entity.updatedDate !== undefined) {
    errors.push(
      _getSchemaValidationError(
        entityName,
        'updatedDate',
        dateToIsoString(entity.updatedDate),
        `updatedDate is auto-generated at the database level`,
        ApiErrorCode.databseSchemaValidationError,
        entity.id
      )
    );
  } else if (model && entity.updatedDate) {
    const modelTime = sanitizeDate(model.updatedDate)?.getTime();
    const entityTime = sanitizeDate(entity.updatedDate)?.getTime();

    if (modelTime !== entityTime) {
      const entityDateString = dateToIsoString(entity.updatedDate);

      errors.push(
        _getSchemaValidationError(
          entityName,
          'updatedDate',
          entityDateString,
          `updatedDate is user immutable, and has mismatched timestamps, this record has been modified since last accessed, please confirm your changes and retry`,
          ApiErrorCode.databaseOptimisticConcurencyError,
          model.id
        )
      );
    }
  }

  (Object.keys(schema) as Extract<keyof T, string>[])
    .filter(
      (k) =>
        entityConstructor.userImmutableFields().indexOf(k) === -1 &&
        typeof schema[k] !== 'string' &&
        !Array.isArray(schema[k])
    )
    .forEach((fieldName) => {
      let fieldErrors: IApiError[] | undefined;
      const field = schema[fieldName] as Readonly<Field>;
      const fieldValue = entity[fieldName];

      if (!field.isNullable && fieldValue === null) {
        errors.push(
          _getSchemaValidationError(
            entityName,
            fieldName,
            null,
            `the field ${fieldName} does not allow null values`,
            ApiErrorCode.databseSchemaValidationError,
            entity.id
          )
        );
      } else if (
        fieldValue === undefined &&
        !model &&
        field.defaultValue !== undefined
      ) {
        errors.push(
          _getSchemaValidationError(
            entityName,
            fieldName,
            null,
            `the field ${fieldName} requires a value on insert`,
            ApiErrorCode.databseSchemaValidationError,
            entity.id
          )
        );
      } else if (field.type === FieldType.varchar) {
        fieldErrors = _validateStringFieldValue(
          entityName,
          fieldName,
          field,
          fieldValue as string | null | undefined,
          model?.id
        );
      } else if (field.type === FieldType.smallint) {
        fieldErrors = _validateIntegerFieldValue(
          entityName,
          fieldName,
          field,
          fieldValue as number | null | undefined,
          model?.id
        );
      }

      if (fieldErrors?.length) {
        for (let i = 0; i < fieldErrors.length; ++i) {
          errors.push(fieldErrors[i]);
        }
      }
    });

  if (errors.length) {
    throw new ApiError(errors);
  }
}
