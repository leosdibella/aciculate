import {
  IBaseModel,
  IForeignKey,
  ISmallIntegerField,
  IStringField
} from '@interfaces';
import { Field, Entity } from '@types';
import { EntityName, FieldType } from '@enums';
import {
  dateToIsoString,
  isPositiveInteger,
  sanitizeDate
} from '@shared/utilities';
import { IApiError } from '@shared/interfaces';
import { ApiErrorCode } from '@shared/enums';
import { ApiError } from '@shared/classes';

function _getSchemaValidationError<T extends IBaseModel>(
  entityName: EntityName,
  fieldName: Extract<keyof T, string>,
  fieldValue: string | undefined | null,
  remainingText: string,
  errorCode:
    | ApiErrorCode.databseSchemaValidationError
    | ApiErrorCode.databaseOptimisticConcurencyError = ApiErrorCode.databseSchemaValidationError,
  id?: string
) {
  const idString = id ? ` with id: '${id}' ` : ' ';

  return {
    errorCode,
    message: `Record of type ${entityName}${idString}has invalid value for field - ${fieldName}: '${fieldValue}', ${remainingText}.`
  };
}

function _getSchemaConfigurationError<T extends IBaseModel>(
  entityName: EntityName,
  fieldName: Extract<keyof T, string>,
  field: Readonly<Field>,
  remainingText: string
) {
  return {
    errorCode: ApiErrorCode.datbaseSchemaConfigurationError,
    message: `Schema Configuration Error - Enttiy: ${entityName} with Field: ${fieldName} of Type: ${field.type}, ${remainingText}.`
  };
}

function _validateIntegerFieldValue<T extends IBaseModel>(
  entityName: EntityName,
  fieldName: Extract<keyof T, string>,
  field: Readonly<ISmallIntegerField>,
  fieldValue: number | undefined | null,
  id?: string
) {
  const errorMessages: string[] = [];

  if (typeof fieldValue !== 'number') {
    errorMessages.push();
  } else if (fieldValue !== (fieldValue | 0)) {
    errorMessages.push('this field must be an integer value');
  }

  return errorMessages.map((errorMessage) =>
    _getSchemaValidationError(
      entityName,
      fieldName,
      `${fieldValue}`,
      errorMessage,
      ApiErrorCode.databseSchemaValidationError,
      id
    )
  );
}

function _validateStringFieldValue<T extends IBaseModel>(
  entityName: EntityName,
  fieldName: Extract<keyof T, string>,
  field: Readonly<IStringField>,
  fieldValue: string | undefined | null,
  id?: string
) {
  const errorMessages: string[] = [];

  if (
    (!field.isNullable && (fieldValue === undefined || fieldValue === null)) ||
    (field.minLength !== undefined &&
      fieldValue !== undefined &&
      fieldValue !== null &&
      fieldValue.length < field.minLength)
  ) {
    errorMessages.push(
      `this field must contain at least ${field.minLength ?? 0} characters`
    );
  }

  if (
    field.maxLength < Infinity &&
    fieldValue !== undefined &&
    fieldValue !== null &&
    fieldValue.length > field.maxLength
  ) {
    errorMessages.push(
      `this field cannot exceed ${field.maxLength} characters`
    );
  }

  return errorMessages.map((errorMessage) =>
    _getSchemaValidationError(
      entityName,
      fieldName,
      fieldValue,
      errorMessage,
      ApiErrorCode.databseSchemaValidationError,
      id
    )
  );
}

export function validateColumnValues<T extends IBaseModel>(
  entity: Entity<T>,
  model?: T
) {
  const errors: IApiError[] = [];

  if (!model && entity.id !== undefined) {
    errors.push(
      _getSchemaValidationError(
        entity.name,
        'id',
        entity.id,
        'ids are auto-generated at the database level'
      )
    );
  } else if (model && entity.id !== model.id) {
    errors.push(
      _getSchemaValidationError(
        entity.name,
        'id',
        entity.id,
        'ids are immutable',
        ApiErrorCode.databseSchemaValidationError,
        model.id
      )
    );
  }

  if (!model && entity.createdBy !== undefined) {
    _getSchemaValidationError(
      entity.name,
      'createdBy',
      entity.createdBy,
      'createdBy is generated by the request context'
    );
  } else if (
    model &&
    entity.createdBy &&
    entity.createdBy !== model.createdBy
  ) {
    _getSchemaValidationError(
      entity.name,
      'createdBy',
      entity.id,
      'createdBy is immutable',
      ApiErrorCode.databseSchemaValidationError,
      model.id
    );
  }

  if (!model && entity.createdDate !== undefined) {
    errors.push(
      _getSchemaValidationError(
        entity.name,
        'createdDate',
        dateToIsoString(entity.createdDate),
        `createdDate is auto-generated at the database level`,
        ApiErrorCode.databseSchemaValidationError,
        entity.id
      )
    );
  } else if (model && entity.createdDate) {
    const modelTime = sanitizeDate(model.createdDate)?.getTime();
    const entityTime = sanitizeDate(entity.createdDate)?.getTime();

    if (modelTime !== entityTime) {
      const entityDateString = dateToIsoString(entity.createdDate);

      _getSchemaValidationError(
        entity.name,
        'createdDate',
        entityDateString,
        `mismatched createdDate values, createdDate is immutable, createdDate for existing record: '${entityDateString}'`,
        ApiErrorCode.databseSchemaValidationError,
        model.id
      );
    }
  }

  if (!model && entity.updatedBy !== undefined) {
    _getSchemaValidationError(
      entity.name,
      'updatedBy',
      entity.updatedBy,
      'updatedBy is generated by the request context'
    );
  } else if (
    model &&
    entity.updatedBy &&
    entity.updatedBy !== model.updatedBy
  ) {
    _getSchemaValidationError(
      entity.name,
      'updatedBy',
      entity.id,
      'updatedBy is user immutable',
      ApiErrorCode.databseSchemaValidationError,
      model.id
    );
  }

  if (!model && entity.updatedDate !== undefined) {
    errors.push(
      _getSchemaValidationError(
        entity.name,
        'updatedDate',
        dateToIsoString(entity.updatedDate),
        `updatedDate is auto-generated at the database level`,
        ApiErrorCode.databseSchemaValidationError,
        entity.id
      )
    );
  } else if (model && entity.updatedDate) {
    const modelTime = sanitizeDate(model.updatedDate)?.getTime();
    const entityTime = sanitizeDate(entity.updatedDate)?.getTime();

    if (modelTime !== entityTime) {
      const entityDateString = dateToIsoString(entity.updatedDate);

      errors.push(
        _getSchemaValidationError(
          entity.name,
          'updatedDate',
          entityDateString,
          `updatedDate is user immutable, and has mismatched timestamps, this record has been modified since last accessed, please confirm your changes and retry`,
          ApiErrorCode.databaseOptimisticConcurencyError,
          model.id
        )
      );
    }
  }

  (Object.keys(entity.schema) as Extract<keyof T, string>[])
    .filter(
      (k) =>
        entity.userImmutableFields.indexOf(k) === -1 &&
        typeof entity.schema[k] !== 'string' &&
        !Array.isArray(entity.schema[k])
    )
    .forEach((fieldName) => {
      let fieldErrors: IApiError[] | undefined;
      const field = entity.schema[fieldName] as Readonly<Field>;
      const fieldValue = entity[fieldName];

      if (!field.isNullable && fieldValue === null) {
        errors.push(
          _getSchemaValidationError(
            entity.name,
            fieldName,
            null,
            `the field ${fieldName} does not allow null values`,
            ApiErrorCode.databseSchemaValidationError,
            entity.id
          )
        );
      } else if (
        fieldValue === undefined &&
        !model &&
        field.defaultValue !== undefined
      ) {
        errors.push(
          _getSchemaValidationError(
            entity.name,
            fieldName,
            null,
            `the field ${fieldName} requires a value on insert`,
            ApiErrorCode.databseSchemaValidationError,
            entity.id
          )
        );
      } else if (field.type === FieldType.varchar) {
        fieldErrors = _validateStringFieldValue(
          entity.name,
          fieldName,
          field,
          fieldValue as string | null | undefined,
          model?.id
        );
      } else if (field.type === FieldType.smallint) {
        fieldErrors = _validateIntegerFieldValue(
          entity.name,
          fieldName,
          field,
          fieldValue as number | null | undefined,
          model?.id
        );
      }

      if (fieldErrors?.length) {
        for (let i = 0; i < fieldErrors.length; ++i) {
          errors.push(fieldErrors[i]);
        }
      }
    });

  if (errors.length) {
    throw new ApiError(errors);
  }
}

function validateColumnConfiguration<T extends IBaseModel>(
  entityName: EntityName,
  fieldName: Extract<keyof T, string>,
  field: Readonly<Field>
) {
  const errors: IApiError[] = [];
  let typeModifierText = '';

  if (field.type === FieldType.varchar) {
    if (!isPositiveInteger(field.maxLength) || field.maxLength !== Infinity) {
      errors.push(
        _getSchemaConfigurationError(
          entityName,
          fieldName,
          field,
          `maxLength: ${field.maxLength} is invalid, must be a postivie integer or ${Infinity}`
        )
      );
    }

    if (
      field.minLength !== undefined &&
      (!isPositiveInteger(field.minLength) ||
        field.minLength > field.maxLength ||
        field.minLength === Infinity)
    ) {
      errors.push(
        _getSchemaConfigurationError(
          entityName,
          fieldName,
          field,
          `minLength: ${field.minLength} is invalid, must be a finite positive integer with value strictly less than the maxLength: ${field.maxLength}`
        )
      );
    }

    typeModifierText = `(${
      isFinite(field.maxLength) ? field.maxLength : 'max'
    })`;
  }

  return {
    typeModifierText,
    errors
  };
}

export function generateColumnDefinitions<T extends IBaseModel>(
  entity: Entity<T>
) {
  const columns: string[] = [];
  const apiErrors: IApiError[] = [];
  const indexes: string[] = [];

  (Object.keys(entity.schema) as Extract<keyof T, string>[])
    .filter(
      (k) =>
        typeof entity.schema[k] !== 'string' && !Array.isArray(entity.schema[k])
    )
    .forEach((fieldName) => {
      const field = entity.schema[fieldName] as Readonly<Field>;

      const { typeModifierText, errors } = validateColumnConfiguration(
        entity.name,
        fieldName,
        field
      );

      const forgienKey: Readonly<IForeignKey> | undefined =
        entity.foreignKeys[fieldName];

      if (forgienKey) {
        indexes.push(
          `CREATE INDEX IF NOT EXISTS ${entity.name}_${fieldName}_index ON ${entity.name} (${fieldName});`
        );
      }

      errors.forEach((e) => apiErrors.push(e));

      const typeText = `${field.type}${typeModifierText}`;

      const primaryKeyText =
        entity.primaryKey === fieldName ? ' PRIMARY KEY ' : '';

      const nullableText =
        field.isNullable || primaryKeyText ? '' : ' NOT NULL ';

      const defaultText =
        field.defaultValue !== undefined
          ? ` DEFAULT ${field.defaultValue} `
          : '';

      const forgienKeyText = forgienKey
        ? ` REFERENCES ${forgienKey.entityName}(${forgienKey.fieldName}) `
        : '';

      const casecadeText = forgienKey?.cascadeOnDelete
        ? ' ON DELETE CASCADE '
        : '';

      columns.push(
        `${fieldName} ${typeText}${primaryKeyText}${nullableText}${defaultText}${forgienKeyText}${casecadeText};`
      );
    });

  if (apiErrors.length) {
    throw new ApiError(apiErrors);
  }

  return {
    columns,
    indexes
  };
}

export function getColumnNamesAndValues<T extends IBaseModel>(
  entity: Entity<T>
) {
  const columnNames: Extract<keyof T, string>[] = [];
  const columnValues: unknown[] = [];

  (Object.keys(entity.schema) as Extract<keyof T, string>[])
    .filter((fieldName) => entity.userImmutableFields.indexOf(fieldName) === -1)
    .forEach((fieldName) => {
      const value = entity[fieldName];

      if (value !== undefined) {
        columnNames.push(fieldName);
        columnValues.push(value);
      }
    });

  return {
    columnNames,
    columnValues
  };
}
